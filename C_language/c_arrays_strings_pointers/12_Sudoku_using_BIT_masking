/*
 * Sudoku Solver using Bitmasking
 * Optimizes space and time by using integer bits to track number availability.
 */

#include <stdio.h>

#define N 9

// Bitmasks: Each integer stores 9 bits. If bit 'n' is 1, number 'n' is used.
int row[N], col[N], box[N];
int initialized = 0; // Better naming than 'seted'

// Maps 2D coordinates (i, j) to a 1D box index (0-8)
int getBox(int i, int j) { 
    return (i / 3) * 3 + (j / 3); 
}

// Checks if 'number' can be placed at grid[i][j]
int isSafe(int i, int j, int number) {
    // Check if the n-th bit is already set in row, column, or box
    return !(row[i] & (1 << number)) &&
           !(col[j] & (1 << number)) &&
           !(box[getBox(i, j)] & (1 << number));
}

// Pre-fills bitmasks with existing numbers from the input grid
void setInitialValues(int grid[N][N]) {
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            if (grid[i][j]) {
                int val = grid[i][j];
                row[i] |= (1 << val); // Set val-th bit to 1
                col[j] |= (1 << val);
                box[getBox(i, j)] |= (1 << val);
            }
        }
    }
}

// Recursive Backtracking Function
int SolveSudoku(int grid[N][N], int i, int j) {
    // Initial setup on first call
    if (!initialized) {
        initialized = 1;
        setInitialValues(grid);
    }

    // Base Case: If we reach the end of the grid, puzzle is solved
    if (i == N - 1 && j == N) return 1;

    // Move to next row if we reach the end of a column
    if (j == N) { j = 0; i++; }

    // Skip cells that already contain a number
    if (grid[i][j]) return SolveSudoku(grid, i, j + 1);

    // Try placing numbers 1 through 9
    for (int nr = 1; nr <= N; nr++) {
        if (isSafe(i, j, nr)) {
            // Place number and update bitmasks
            grid[i][j] = nr;
            row[i] |= (1 << nr);
            col[j] |= (1 << nr);
            box[getBox(i, j)] |= (1 << nr);

            // Recurse to next cell
            if (SolveSudoku(grid, i, j + 1)) return 1;

            // BACKTRACK: Undo choice and clear bitmasks
            grid[i][j] = 0;
            row[i] &= ~(1 << nr); // Flip 1 to 0 using Bitwise NOT and AND
            col[j] &= ~(1 << nr);
            box[getBox(i, j)] &= ~(1 << nr);
        }
    }
    return 0; // Trigger backtracking
}

void print(int grid[N][N]) {
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            printf("%d ", grid[i][j]);
        }
        printf("\n");
    }
}

int main() {
    int grid[N][N] = { 
        { 5, 3, 0, 0, 7, 0, 0, 0, 0 },
        { 6, 0, 0, 1, 9, 5, 0, 0, 0 },
        { 0, 9, 8, 0, 0, 0, 0, 6, 0 },
        { 8, 0, 0, 0, 6, 0, 0, 0, 3 },
        { 4, 0, 0, 8, 0, 3, 0, 0, 1 },
        { 7, 0, 0, 0, 2, 0, 0, 0, 6 },
        { 0, 6, 0, 0, 0, 0, 2, 8, 0 },
        { 0, 0, 0, 4, 1, 9, 0, 0, 5 },
        { 0, 0, 0, 0, 8, 0, 0, 7, 9 } 
    };

    if (SolveSudoku(grid, 0, 0)) print(grid);
    else printf("No solution exists\n");

    return 0;
}